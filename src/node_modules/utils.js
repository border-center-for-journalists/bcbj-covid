import Papa from 'papaparse';

export async function serialize(dataSource) {
  const res = await fetch(dataSource);
  const csv = await res.text();
  const json = Papa.parse(csv.trim(), { header: true }).data;
  return json;
}

export async function serializeUS(dataSource) {
  const res = await fetch(dataSource);
  const json = await res.json();
  return json;
}

export async function loadData() {
  const baseURL = 'https://raw.githubusercontent.com/el-sonny/mxcovidserialize/master/data/output/';
  const [confirmed, deaths, usa] = await Promise.all([
    serialize(baseURL + 'csv/confirmed-time-series.csv'),
    serialize(baseURL + 'csv/deaths-time-series.csv'),
    serializeUS(baseURL + 'timeSeriesUS.json')
  ]);
  return { confirmed, deaths, usa };
}

export function formatUS(usData) {
  const serialized = usData.map(county => {
    const title = county.name + ', ' + county.state;
    const confirmed = Object.values(county.entries).map(entry => entry.confirmed);
    const deaths = Object.values(county.entries).map(entry => entry.deaths);
    const dates = Object.keys(county.entries);
    const confirmedPerCapita = confirmed.map(c => (c * 10000 / county.population).toFixed(1));
    const deathsPerCapita = deaths.map(c => (c * 10000 / county.population).toFixed(1));
    return {
      id: county.fips,
      title,
      lat: county.lat,
      lon: county.lon,
      population: county.population,
      dates,
      confirmed,
      deaths,
      confirmedPerCapita,
      deathsPerCapita,
      country: 'us'
    }

  });
  return serialized;
}

//Recieves the loaded data then combines deaths and confirmed cases into one object.
export function combineData(data) {
  const dates = Object.keys(data.confirmed[0]).slice(9);

  return data.confirmed.map((m, i) => {
    const together = `${m.municipalityName}, ${m.entityName}`;
    const title = (together.length > 35) ? `${m.municipalityName}, <br /> ${m.entityName}` : together;
    const confirmed = Object.values(m).slice(9);
    const deaths = Object.values(data.deaths[i]).slice(9);
    const confirmedPerCapita = confirmed.map(c => (c * 10000 / m.population).toFixed(1));
    const deathsPerCapita = deaths.map(d => (d * 10000 / m.population).toFixed(1));
    return {
      id: m.entityCode + m.municipalityCode,
      title,
      lat: m.popCenterLat,
      lon: m.popCenterLon,
      population: m.population,
      dates,
      confirmed,
      deaths,
      confirmedPerCapita,
      deathsPerCapita,
      country: 'mx'
    };

  });
}

export function makeMarkers(municipalities, dimension, dateIndex) {
  dateIndex = dateIndex !== undefined ? dateIndex : municipalities[0].dates.length - 1;
  const markers = municipalities.map(m => {
    const cases = m[dimension][dateIndex];
    const radius = Math.ceil(cases * 25 / 2000);
    const weight = cases > 0 ? 1 : 0;
    const fillOpacity = cases > 0 ? .3 : 0;
    let marker = L.circleMarker([m.lat, m.lon], {
      radius,
      weight,
      fillOpacity,
      color: '#fdf903',
      fillColor: '#fdf903'
    });
    //This id is used to relate with the hover layer and highlight the marker
    marker.id = m.id;
    return marker;
  });

  const hoverMarkers = municipalities.map(m => {
    const cases = m[dimension][dateIndex];
    const radius = Math.ceil(cases * 25 / 2000) + 10;
    let marker = L.circleMarker([m.lat, m.lon], {
      radius: radius,
      stroke: false,
      fillOpacity: 0,
      className: 'custom-tooltip'
    })
      .bindTooltip(`<div>
                <p>${m.title}</p>
                <div class='tooltip-row tooltip-header'>
                  <div></div>
                  <div><span>Total<span></div>
                  <div><span>Por 100,000<br/> personas<span></div>
                </div>
                <div class='tooltip-row'>
                  <div>Casos</div>
                  <div><strong>${new Intl.NumberFormat().format(m.confirmed[dateIndex])}</strong></div>
                  <div><strong>${m.confirmedPerCapita[dateIndex]}</strong></div>
                </div>
                <div class='tooltip-row'>
                  <div>Muertes</div>
                  <div><strong>${m.deaths[dateIndex]}</strong></div>
                  <div><strong>${m.deathsPerCapita[dateIndex]}</strong></div>
                </div>
            </div>`, {
        direction: 'top',
        sticky: true
      })
      .on('mouseover', e => visibleLayer.customGetLayer(e.sourceTarget.id).setStyle({ color: '#000' }))
      .on('mouseout', e => visibleLayer.customGetLayer(e.sourceTarget.id).setStyle({ color: '#fdf903' }));
    marker.id = m.id;
    return marker;
  });

  const visibleLayer = L.layerGroup(markers);
  const hoverLayer = L.layerGroup(hoverMarkers);
  return [visibleLayer, hoverLayer];
}
//This Extends Leaflet to allow markers to be fecthed from custom set ID's allowing us to relate the visible markers and the hover markers for circle-highlights.
export function setCustomGetLayer() {
  L.LayerGroup.include({
    customGetLayer: function (id) {
      for (var i in this._layers) {
        if (this._layers[i].id == id) {
          return this._layers[i];
        }
      }
    }
  });
}

export const getLastUpdateDate = (data) => {
  const { dates } = data[0]
  if (!dates) return ""
  const size = dates.length - 1
  return dates[size]
}

export const updateMarkers = (municipalities, dimension, visibleLayer, hoverLayer, dateIndex) => {
  const datesLength = municipalities[0].dates.length - 1
  dateIndex = dateIndex !== undefined ? dateIndex : datesLength;
  dateIndex = dateIndex > datesLength ? datesLength : dateIndex

  const localVisibleMarkers = visibleLayer.getLayers()
  localVisibleMarkers.forEach((mrk, index) => {
    const cases = municipalities[index][dimension][dateIndex];
    const radius = Math.ceil(cases * 25 / 2000);
    const m = municipalities[index];
    mrk.setRadius(radius)
  });

  const localHoverLayer = hoverLayer.getLayers()
  localHoverLayer.forEach((mrk, index) => {
    const cases = municipalities[index][dimension][dateIndex];
    const radius = Math.ceil(cases * 25 / 2000) + 10;
    const m = municipalities[index];
    mrk.setRadius(radius)
  });
}